## :one: A형 대비

## 목록

| 문제                                                         | 출처      | 기타                   |
| ------------------------------------------------------------ | --------- | ---------------------- |
| [2667.단지번호붙이기][BOJ2667]        [<문제보기>](#단지번호붙이기) | BOJ       | DFS or BFS             |
| [2468.안전영역][BOJ2468]                   [<문제보기>](#안전영역) | BOJ       | DFS or BFS             |
| [2636.치즈][BOJ2636]                           [<문제보기>](#치즈) | BOJ       | DFS or BFS             |
| [17144.미세먼지 안녕!](https://www.acmicpc.net/problem/17144)       [<문제보기>](#미세먼지-안녕) | BOJ       |                        |
| [17136.색종이 붙이기](https://www.acmicpc.net/problem/17136)        [<문제보기>](#색종이-붙이기) | BOJ       | 백트래킹               |
| [2573.빙산][BOJ2573]                           [<문제보기>](#빙산) | BOJ       |                        |
| [2589.보물섬][BOJ2589]                       [<문제보기>](#보물섬) | BOJ       | BFS                    |
| [16234.인구이동][BOJ16234]                 [<문제보기>](#인구이동) | BOJ       | BFS, set.update() 활용 |
| [14889.스타트와 링크][BOJ14889]        [<문제보기>](#스타트와-링크) | BOJ       | 조합                   |
| [14502.연구소][BOJ14502]                     [<문제보기>](#연구소) | BOJ       | 조합, BFS or DFS       |
| [14501.퇴사][BOJ14501]                         [<문제보기>](#퇴사) | BOJ       |                        |
| [15686.치킨배달][BOJ15686]                 [<문제보기>](#치킨배달) | BOJ       |                        |
| [14888.연산자 끼워넣기][BOJ14888]     [<문제보기>](#연산자-끼워넣기) | BOJ       | 백트래킹               |
| [17471.게리맨더링][BOJ17471]             [<문제보기>](#게리맨더링) | BOJ       |                        |
| [17070.파이프 옮기기1][BOJ17070]      [<문제보기>](#파이프-옮기기1) | BOJ       |                        |
| [15683.감시][BOJ15683]                         [<문제보기>](#감시) | BOJ       |                        |
| [17135.캐슬디펜스][BOJ17135]             [<문제보기>](#캐슬디펜스) | BOJ       |                        |
| --------------------------------                             | --------- | -----------            |
| [14503.로봇청소기][BOJ14503]             [<문제보기>](#로봇청소기) | BOJ       | 백트래킹               |
| [16235.나무재테크][BOJ16235]             [<문제보기>](#나무재테크) | BOJ       |                        |
| [17837.새로운게임2][BOJ17837]           [<문제보기>](#새로운게임2) | BOJ       |                        |
| [12100.2048][BOJ12100]                        [<문제보기>](#2048) | BOJ       |                        |
| [17142.연구소3][BOJ17142]                   [<문제보기>](#연구소3) | BOJ       |                        |
| [2146.다리만들기][BOJ2146]               [<문제보기>](#다리만들기) | BOJ       |                        |
| [17472.다리만들기2][BOJ17472]           [<문제보기>](#다리만들기2) | BOJ       |                        |
| [2644.촌수계산][BOJ2644]                   [<문제보기>](#촌수계산) | BOJ       |                        |
| [2479.경로찾기][BOJ2479]                   [<문제보기>](#경로찾기) | BOJ       |                        |
| [1726.로봇][BOJ1726]                           [<문제보기>](#로봇) | BOJ       |                        |
| [10711.모래성][BOJ10711]                     [<문제보기>](#모래성) | BOJ       | SWEA 1907.모래성 쌓기  |
| --------------------------------                             | --------- | -----------            |
| 1867.프로세서 연결하기   [<문제보기>](#프로세서-연결하기)    | SWEA      |                        |
| 1949.등산로조성                [<문제보기>](#등산로조성)     | SWEA      |                        |
| 1953.탈주범검거                [<문제보기>](#탈주범검거)     | SWEA      |                        |
| [1952.수영장](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq)                        [<문제보기>](#수영장) | SWEA      | 백트래킹               |
| 2382.미생물격리                [<문제보기>](#미생물격리)     | SWEA      |                        |
| 2105.디저트카페                [<문제보기>](#디저트카페)     | SWEA      |                        |
| 5650.핀볼 게임                   [<문제보기>](#핀볼-게임)    | SWEA      |                        |
| 5656.벽돌깨기                    [<문제보기>](#벽돌깨기)     | SWEA      |                        |
| 4008. 숫자만들기               [<문제보기>](#숫자만들기)     |           |                        |
| --------------------------------                             | --------- | -----------            |
| 그 외                                                        |           |                        |
| 2611.좋은수열                    [<문제보기>](#좋은수열)     |           |                        |
|                                                              |           |                        |

[BOJ12100]: https://www.acmicpc.net/problem/12100
[BOJ14503]: https://www.acmicpc.net/problem/14503
[BOJ16235]: https://www.acmicpc.net/problem/16235
[BOJ17837]: https://www.acmicpc.net/problem/17837
[BOJ17142]: https://www.acmicpc.net/problem/17142
[BOJ2146]: https://www.acmicpc.net/problem/2146
[BOJ17472]: https://www.acmicpc.net/problem/17472
[BOJ2644]: https://www.acmicpc.net/problem/2644
[BOJ2479]: https://www.acmicpc.net/problem/2479
[BOJ1726]: https://www.acmicpc.net/problem/1726
[BOJ10711]: https://www.acmicpc.net/problem/10711


[BOJ2667]: https://www.acmicpc.net/problem/2667
[BOJ2468]: https://www.acmicpc.net/problem/2468
[BOJ2636]: https://www.acmicpc.net/problem/2636
[BOJ2573]: https://www.acmicpc.net/problem/2573
[BOJ2589]: https://www.acmicpc.net/problem/2589
[BOJ16234]: https://www.acmicpc.net/problem/16234
[BOJ14889]: https://www.acmicpc.net/problem/14889
[BOJ14501]: https://www.acmicpc.net/problem/14501
[BOJ15686]: https://www.acmicpc.net/problem/15686
[BOJ14888]: https://www.acmicpc.net/problem/14888
[BOJ14502]: https://www.acmicpc.net/problem/14502
[BOJ17070]: https://www.acmicpc.net/problem/17070
[BOJ15683]: https://www.acmicpc.net/problem/15683
[BOJ17471]: https://www.acmicpc.net/problem/17471
[BOJ17135]: https://www.acmicpc.net/problem/17135



## 단지번호붙이기 [목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74249787-10dce300-4d2d-11ea-8f2d-ce57f7f5855b.png)





```python
# DFS (1)
# result 리스트를 만들어서 단지 수 추가
# len(result) 출력하고
# result 를 오름차순 정렬한 후 print

dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]

def dfs(x, y):
    global cnt
    # 방문했으면 그 지점은 0으로 변경
    arr[x][y] = 0
    visit[x][y] = True
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        # 경계조건 + 방문조건 + 맵에서의 위치 값 == 1
        if 0 <= nx < N and 0 <= ny < N and not visit[nx][ny] and arr[nx][ny] == 1:
            cnt += 1
            dfs(nx, ny)
    return cnt

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
# print(arr)

visit = [[False]*N for _ in range(N)]
res = []
# 1인 지점을 만났을 때 그 지점을 개수에 포함시켜야 하므로
# cnt = 1로 시작한다.
cnt = 1
for i in range(N):
    for j in range(N):
        # 맵은 하나로 고정 되어있기 때문에
        # not visit으로 끊어낼 수 있다
        if arr[i][j] == 1 and not visit[i][j]:
            dfs(i, j)
            res.append(cnt)
            cnt = 1

# .sort()는 변경사항이 저장됨
res.sort()
print(len(res))
for i in res:
    print(i)
```





## 안전영역

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74350254-cfb20500-4df8-11ea-8ef5-e6fb9998c853.png)





```python
# pypy 말고 python3로 제출해야됨
import sys
sys.setrecursionlimit(10000)

def dfs(x, y):
    visit[x][y] = True
    # 아래 배열을 돌 때 i, j를 사용했기 때문에
    # 다른 변수 k 를 사용하는 것이 안전하다
    for k in range(4):
        nx, ny = x+dx[k], y+dy[k]
        if 0 <= nx < N and 0 <= ny < N:
            if arr[nx][ny] > height and not visit[nx][ny]:
                dfs(nx, ny)


N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

# 섬의 높이 범위내에서 판단하면됨
# 최소값, 최대값을 미리 찾아두고 범위를 좁히는데 사용
Max_h, Min_h = 0, 100
for i in range(N):
    for j in range(N):
        if Max_h <= arr[i][j]: Max_h = arr[i][j]
        if Min_h >= arr[i][j]: Min_h = arr[i][j]

# <<중요>> 모든 지역이 안전지역인 경우 그룹 수 : 1
Max = 1

# 높이의 최소값, 최대값 범위를 돌며 Max 뽑아냄
for height in range(Min_h, Max_h+1):
    cnt = 0
    visit = [[False] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if height < arr[i][j] and not visit[i][j]:
                cnt += 1
                dfs(i, j)

    if Max <= cnt:
        Max = cnt

print(Max)
```





## 치즈

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75030254-0ff34080-54e7-11ea-8fda-1ad6f33e36ec.png)



```python
import sys; sys.stdin = open('txt/2636_치즈.txt', 'r')
from pprint import pprint
import collections
sys.setrecursionlimit(10000)

# 외부 공기인 경우 'o'로 바꾸는 작업
def dfs(a, b):
    visit[a][b] = True
    arr[a][b] = 'o'
    for l in range(4):
        na, nb = a+dx[l], b+dy[l]
        if 0 <= na < N and 0 <= nb < M:
            if (arr[na][nb] == 0 or arr[na][nb] == 'o') and not visit[na][nb]:
                dfs(na, nb)

# 주변에 외부 공기가 있으면 테두리 치즈('c')로 변경
def find(x, y):
    global cnt
    visit[x][y] = True
    for k in range(4):
        nx, ny = x+dx[k], y+dy[k]
        if arr[nx][ny] == 'o':
            arr[x][y] = 'c'
            return

N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
result = []

time = 0
while True:
    one = 0
    for find_one in arr:
        one += find_one.count(1)
    result.append(one)
    # print(result)

    visit = [[False] * M for _ in range(N)]
    # 테두리가 만들어져 있기 때문에 (0, 0)에서 시작
    dfs(0, 0)

    # 모두 공기로 바뀌었을 때 종료
    cnt = 0
    for lst in arr:
        cnt += lst.count('o')
    if cnt == N * M: break

    # 공기와 맞닿은 치즈인지
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 1:
                find(i, j)

    # 공기와 맞닿은 치즈인 경우
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 'c':
                arr[i][j] = 'o'

    # 모든 작업이 끝난 후 시간 + 1
    time += 1

print(time)
print(result[-2])
```





## 미세먼지 안녕! 

[목록](#목록)



```python

```







## 색종이 붙이기 

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74669227-11bcbb80-51ea-11ea-8bfb-dbf8e7d40bb8.png)



**문제 잘 읽고 조건 빼먹으면 안됨

```python
def dfs(depth):
    global Min, cnt_one

    # 이미 최소값보다 depth가 커지면 더이상 탐색 안하고 리턴
    if Min > 0 and Min <= depth:
        return

    # 남은 1이 없을 때 depth가 최소값보다 작다면(최초에 answer는 -1)
    if cnt_one == 0:
        if Min == -1 or Min > depth:
            Min = depth  # 값을 할당하고 리턴
        return

    # 1이 있는곳에서 시작(좌상단)
    for x in range(10):
        for y in range(10):
            if MAP[x][y]:
                break
        if MAP[x][y]:
            break

    # 끝까지 갔는데 그 자리가 0이면 조사할 필요없음
    if x == 9 and y == 9 and MAP[x][y] == 0: return

    # 해당 점에 1~5 사이즈를 대본다.
    for size in range(1, 5 + 1):
        # 종이가 남아있을 때 진행
        if paper[size]:
            one_zero = []  # 1 에서 0으로 바뀐 좌표 저장해서 나중에 도로 바꿔준다.

            if isCoverable(x, y, size):  # 해당 사이즈로 덮을 수 있다면
                # 색종이로 덮어지는 부분을 0으로 변경
                for next_x in range(x, x + size):
                    for next_y in range(y, y + size):
                        MAP[next_x][next_y] = 0  # 1에서 0 으로 바꾸고
                        one_zero.append((next_x, next_y))  # 좌표를 저장

                # 색종이가 붙여졌기 때문에 넓이만큼 1의 개수가 줄어듦
                cnt_one -= size ** 2
                paper[size] -= 1
                dfs(depth + 1)
                # 다시 탐색하기 위해 값을 되돌림
                paper[size] += 1
                cnt_one += size ** 2

            # 바뀐 좌표들을 다시 0에서 1로 바꿔줌
            for x_y in one_zero:
                MAP[x_y[0]][x_y[1]] = 1


# 색종이로 채울 수 있는지 검사
def isCoverable(x, y, size):
    for i in range(x, x + size):
        for j in range(y, y + size):
            if i < 10 and j < 10:
                # 0인 곳에는 색종이가 붙으면 안된다. **** 문제 조건 잘 읽기!
                if MAP[i][j] == 0:
                    return False
            # 색종이가 MAP 범위를 벗어나면 안된다.
            else:
                return False
    return True

for _ in range(int(input())):
    MAP = [list(map(int, input().split())) for _ in range(10)]
    paper = [0, 5, 5, 5, 5, 5]
    Min = -1
    cnt_one = sum(sum(m) for m in MAP)
    dfs(0)
    print(Min)
```





## 보물섬

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75251343-c0ca4a00-581d-11ea-9f72-8f4ee873b30e.png)



```python
import collections

# 모든 'L'을 돌면서 각 자리에서 가장 멀리 있는 'L'까지의 거리를 구하고
# 그 거리들 중 최대값을 구하는 문제
dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]

# bfs로 풀어야 이동 거리를 알 수 있음
def bfs(x, y, d):
    Max = 0
    visit[x][y] = True
    Q = collections.deque()
    Q.append((x, y, d))
    while Q:
        x, y, d = Q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and arr[nx][ny] == 'L':
                # pop해 온 자리에서 이동할 수 있으면 d+1
                Q.append((nx, ny, d+1))
                visit[nx][ny] = True
        Max = max(Max, d)
    return Max

N, M = map(int, input().split())
arr = [list(input()) for _ in range(N)]

ans = 0
for i in range(N):
    for j in range(M):
        # 모든 'L'을 돌며 탐색
        if arr[i][j] == 'L':
            visit = [[False]*M for _ in range(N)]
            ans = max(bfs(i, j, 0), ans)


print(ans)
```



## 인구이동

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75415907-5f66c000-5970-11ea-87e2-9814c0025850.png)



```python
import collections

def bfs(map, a, b):
    q = collections.deque()
    union = set()
    q.append((a, b))
    while q:
        x, y = q.popleft()
        visit[x][y] = True
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            # 경계조건 + 방문확인
            if 0 <= nx < N and 0 <= ny < N and not visit[nx][ny]:
                # 국경선 open/close 조건
                if L <= abs(map[x][y] - map[nx][ny]) <= R:
                    # set.update(리스트) : 없는 항목만 set에 추가
                    union.update([(x, y), (nx, ny)])
                    q.append((nx, ny))
    return union


dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

for _ in range(int(input())):
    N, L, R = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    day = 0
    while True:
        visit = [[False]*N for _ in range(N)]
        results = []
        for i in range(N):
            for j in range(N):
                if not visit[i][j]:
                    results.append(bfs(arr, i, j))

        # total = 0 을 여기에 두고 돌리는 실수를 해서 계속 틀림
        for result in results:
            total = 0
            if result:
                # 연합국 안에서 평균값 구하고
                for a, b in result:
                    total += arr[a][b]
                avg = total // len(result)
                
                # 국가별 인구를 평균값으로 변경
                for a, b in result:
                    arr[a][b] = avg

        # 인구이동 종료조건
        if len(results) == N*N: break

        day += 1
    print(day)
```





## 스타트와 링크

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75406860-e9089480-5954-11ea-8c78-c07c20ea060b.png)



```python
from itertools import combinations

for _ in range(int(input())):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    member = list(range(N))

    Min = 999999    
    # 팀을 두 개로 나누기 (조합)
    for group1 in combinations(member, N // 2):
        group2 = list(set(member) - set(group1))

        # 1팀, 2팀 능력치 계산
        team_1, team_2 = 0, 0
        for i, j in combinations(group1, 2):
            team_1 += arr[i][j] + arr[j][i]
        for i, j in combinations(group2, 2):
            team_2 += arr[i][j] + arr[j][i]
        Min = min(Min, abs(team_1 - team_2))

    print(Min)
```





## 연구소

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75025092-e2ee6000-54dd-11ea-9dd2-a4b44e634c03.png)



```python
import itertools
import collections
import copy
from pprint import pprint
# bfs : 964 ms
# dfs : 1340 ms

dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

def bfs(x, y):
    Q = collections.deque()
    Q.append((x, y))
    while Q:
        x, y = Q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and copied_arr[nx][ny] == 0:
                copied_arr[nx][ny] = 2
                visit[nx][ny] = True
                Q.append((nx, ny))

def dfs(x, y):
    visit[x][y] = True
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and copied_arr[nx][ny] == 0:
            copied_arr[nx][ny] = 2
            visit[nx][ny] = True
            dfs(nx, ny)


for _ in range(int(input())):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 바이러스와 빈칸의 좌표 저장
    virus = []
    place = []
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 2:
                virus.append((i, j))
            elif arr[i][j] == 0:
                place.append((i, j))

    Max = 0
    # 빈 칸들 중 3개 뽑는 조합
    for comb in itertools.combinations(place, 3):
        # 각 경우마다 맵 새로해줌
        copied_arr = copy.deepcopy(arr)
        visit = [[False] * M for _ in range(N)]
        # 벽 세우기
        for x, y in comb:
            copied_arr[x][y] = 1

        # 바이러스 퍼뜨리기
        for x, y in virus:
            bfs(x, y)
            # dfs(x, y)

        # 바이러스 안퍼진 곳 개수 카운트
        cnt = 0
        for i in range(N):
            for j in range(M):
                if copied_arr[i][j] == 0:
                    cnt += 1

        Max = max(Max, cnt)

    print(Max)
```



## 치킨배달

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75611652-c1d1e300-5b5f-11ea-8f9d-4c3e7f578beb.png)



```python
# 치킨집 하나에 여러집이 연결될 수 있다.
from itertools import combinations

for _ in range(int(input())):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    home = []
    chicken = []
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 1:
                home.append((i, j))
            elif arr[i][j] == 2:
                chicken.append((i, j))
    
    ans = 0xfffffff
    for chick in combinations(chicken, M):
        # 각 경우마다 res값 0부터 시작
        res = 0
        for home_x, home_y in home:
            Min = 0xfffffff
            # 각 집에서 가장 가까운 치킨집 거리 저장
            for chick_x, chick_y in chick:
                Min = min(Min, abs(home_x-chick_x)+abs(home_y-chick_y))
            res += Min
        ans = min(res, ans)
    
    print(ans)
```





## 연산자 끼워넣기

[목록](#목록)



![image](https://user-images.githubusercontent.com/52685247/75352880-cc854180-58ed-11ea-9bdd-edce0cbec8c2.png)



```python
def cal(idx, val, plus, minus, mul, div):
    global Max, Min
    if idx == N:
        Max = max(Max, val)
        Min = min(Min, val)

    if plus:
        cal(idx + 1, val + nums[idx], plus - 1, minus, mul, div)
    if minus:
        cal(idx + 1, val - nums[idx], plus, minus - 1, mul, div)
    if mul:
        cal(idx + 1, val * nums[idx], plus, minus, mul - 1, div)
    if div:
        cal(idx + 1, int(val / nums[idx]), plus, minus, mul, div - 1)

for _ in range(int(input())):
    N = int(input())
    nums = list(map(int, input().split()))
    plus, minus, mul, div = map(int, input().split())

    Max = -999999999
    Min = 999999999
    cal(1, nums[0], plus, minus, mul, div)
    print(Max)
    print(Min)
```



## 로봇청소기

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74440063-a785dd00-4eb0-11ea-8e9e-3e862370d954.png)





```python
# 북 동 남 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def clean(x, y, d, cnt):
    visit[x][y] = True
    # 왼쪽 방향으로 돌아야하니
    # dx, dy 작성한 것의 반대 방향으로 돌아야 함
    for i in range(-3, 1):
        ndir = (d-i)%4
        nx = x+dx[ndir]
        ny = y+dy[ndir]
        # 진행하는 방향이 청소할 수 있는 곳이면
        # 이동해서 청소 (위치, 방향 바꾸고 cnt+1)
        if 0 <= nx < N and 0 <= ny < M:
            if not arr[nx][ny] and not visit[nx][ny]:
                clean(nx, ny, ndir, cnt+1)
                return

    # 네 방향 다 체크하며 clean이 모두 동작한 후
    # 처음 보던 방향의 반대(-) 방향 체크
    # 뒤쪽 방향이 벽이라면 끝낸다
    if arr[x-dx[d]][y-dy[d]]:
        print(cnt)
        return
    else:
        clean(x-dx[d], y-dy[d], d, cnt)


for _ in range(int(input())):
    N, M = map(int, input().split())
    loc_x, loc_y, head = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    visit = [[False]*M for _ in range(N)]
    # 현재 위치 청소하기 때문에 cnt = 1 부터 시작
    clean(loc_x, loc_y, head, 1)
```

 





## 좋은수열

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75259822-f9712000-582b-11ea-8337-10c235e51b66.png)



```python
def backtrack(idx):
    # 끝에서 부터 1개, 2개, ...i개씩 비교
    for i in range(1, (idx//2) + 1):
        if num[-i:] == num[2 * (-i):-i]:
            return -1
    
    # 종료조건
    if idx == n:
        for i in range(n):
            print(num[i], end='')
            
        # return 0을 해서 함수를 끝낼 수 있도록 함
        return 0

    # 작은수부터 차례대로 맨 끝에 붙여보고
    # 좋은 수열인지 판단
    for i in range(1, 4):
        num.append(i)
        if backtrack(idx + 1) == 0:
            return 0
        
        # return 이 -1이면 좋은수열이 아님
        num.pop()

n = int(input())
num = []
backtrack(0)
```



```
1211 => 길이 4, 1자리 비교, 나쁜 수열

---------------------------------

1212 => 길이 4, 1자리 비교, 좋은 수열

1212 => 길이 4, 2자리 비교, 나쁜 수열

---------------------------------

123123 => 길이 6, 1자리 비교, 좋은 수열

123123 => 길이 6, 2자리 비교, 좋은 수열

123123 => 길이 6, 3자리 비교, 나쁜 수열
```





## 수영장

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75517419-f9e30400-5a41-11ea-8277-e5cb52ea22cb.png)



```python
def swim(price, date):
    global Min
    # 마지막 한 달이 남았더라도 세 달치가 더 저렴하다면
    # 세 달치로 결제할 수 있음
    # ==> date가 12를 넘어도 됨
    if date >= 12:
        Min = min(Min, price)
        return

    # 해당하는 달에 이용 계획이 없으면 다음달로 넘어감
    if not schedule[date]:
        swim(price, date+1)

    # 이용 계획이 있는 경우 백트래킹 진행
    else:
        swim(price + day*schedule[date], date+1)
        swim(price + month, date+1)
        swim(price + month_3, date+3)

for tc in range(1, int(input())+1):
    day, month, month_3, year = list(map(int, input().split()))
    schedule = list(map(int, input().split()))

    # 일년치 결제하는 것보다 더 많이 나올 수 없음
    Min = year
    swim(0, 0)

    print('#{} {}'.format(tc, Min))
```



## 숫자만들기

![image](https://user-images.githubusercontent.com/52685247/75648739-550c3500-5c94-11ea-8a62-26a3929767b9.png)



```python
def cal(res, cnt, plus, minus, mul, div):
    global Max, Min
    if cnt == N:
        Max = max(Max, res)
        Min = min(Min, res)

    if plus:
        cal(res+arr[cnt], cnt+1, plus-1, minus, mul, div)
    if minus:
        cal(res-arr[cnt], cnt+1, plus, minus-1, mul, div)
    if mul:
        cal(res*arr[cnt], cnt+1, plus, minus, mul-1, div)
    if div:
        cal(int(res/arr[cnt]), cnt+1, plus, minus, mul, div-1)


for tc in range(1, int(input())+1):
    N = int(input())
    plus, minus, mul, div = map(int, input().split())
    arr = list(map(int, input().split()))

    Max = -999999999
    Min = 999999999
    cal(arr[0], 1, plus, minus, mul, div)
    print(f'#{tc} {Max-Min}')
```





















---

```python
def f(n, k):
    if n==k: # b의 모든 칸이 결정됨
        for i in range(k):
            if b[i] == 1:
                print(b[i], end='')
        print()
    else:
        pass
```



결정이 되었으면 출력



부분집합 원소의 합



```python
def f(n, k, s):
    if n==k:
        print(s)
    else:
        f(n+1, k, s+A[n])
        f(n+1, k, s)
```



문제를 보고 상태 트리를 만들어보는 연습