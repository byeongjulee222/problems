# :one: A형 대비

- 소프트웨어 검정시험 대비 및 알고리즘 문제풀이 능력 향상을 위해 주기적으로 문제를 풀고 그 풀이를 정리해두기 위해 작성



## 목록

| 문제                                                         | 출처      | 기타                      |
| ------------------------------------------------------------ | --------- | ------------------------- |
| [2667.단지번호붙이기][BOJ2667]        [<문제보기>](#단지번호붙이기) | BOJ       | DFS or BFS                |
| [2468.안전영역][BOJ2468]                   [<문제보기>](#안전영역) | BOJ       | DFS or BFS                |
| [2636.치즈][BOJ2636]                           [<문제보기>](#치즈) | BOJ       | DFS or BFS                |
| [17144.미세먼지 안녕!](https://www.acmicpc.net/problem/17144)       [<문제보기>](#미세먼지-안녕) | BOJ       | 시뮬레이션, 리스트 회전   |
| [17136.색종이 붙이기](https://www.acmicpc.net/problem/17136)        [<문제보기>](#색종이-붙이기) | BOJ       | 백트래킹                  |
| [2573.빙산][BOJ2573]                           [<문제보기>](#빙산) | BOJ       |                           |
| [2589.보물섬][BOJ2589]                       [<문제보기>](#보물섬) | BOJ       | BFS                       |
| [16234.인구이동][BOJ16234]                 [<문제보기>](#인구이동) | BOJ       | BFS, set.update() 활용    |
| [14889.스타트와 링크][BOJ14889]        [<문제보기>](#스타트와-링크) | BOJ       | 조합                      |
| [14502.연구소][BOJ14502]                     [<문제보기>](#연구소) | BOJ       | 조합, BFS or DFS          |
| [14501.퇴사][BOJ14501]                         [<문제보기>](#퇴사) | BOJ       | DP                        |
| [15686.치킨배달][BOJ15686]                 [<문제보기>](#치킨배달) | BOJ       | 조합                      |
| [14888.연산자 끼워넣기][BOJ14888]     [<문제보기>](#연산자-끼워넣기) | BOJ       | 백트래킹                  |
| [17471.게리맨더링][BOJ17471]             [<문제보기>](#게리맨더링) | BOJ       | DFS                       |
| [17070.파이프 옮기기1][BOJ17070]      [<문제보기>](#파이프-옮기기1) | BOJ       |                           |
| [15683.감시][BOJ15683]                         [<문제보기>](#감시) | BOJ       | 백트래킹                  |
| [17135.캐슬디펜스][BOJ17135]             [<문제보기>](#캐슬디펜스) | BOJ       | 시뮬레이션                |
| --------------------------------                             | --------- | -----------               |
| [14503.로봇청소기][BOJ14503]             [<문제보기>](#로봇청소기) | BOJ       | 재귀                      |
| [16235.나무재테크][BOJ16235]             [<문제보기>](#나무재테크) | BOJ       |                           |
| [17837.새로운게임2][BOJ17837]           [<문제보기>](#새로운게임2) | BOJ       |                           |
| [12100.2048][BOJ12100]                        [<문제보기>](#2048) | BOJ       | 트리? BFS?                |
| [17142.연구소3][BOJ17142]                   [<문제보기>](#연구소3) | BOJ       |                           |
| [2146.다리만들기][BOJ2146]               [<문제보기>](#다리만들기) | BOJ       |                           |
| [17472.다리만들기2][BOJ17472]           [<문제보기>](#다리만들기2) | BOJ       |                           |
| [2644.촌수계산][BOJ2644]                   [<문제보기>](#촌수계산) | BOJ       | BFS                       |
| [2479.경로찾기][BOJ2479]                   [<문제보기>](#경로찾기) | BOJ       |                           |
| [1726.로봇][BOJ1726]                           [<문제보기>](#로봇) | BOJ       |                           |
| [10711.모래성][BOJ10711]                     [<문제보기>](#모래성) | BOJ       | SWEA 1907.모래성 쌓기     |
| --------------------------------                             | --------- | -----------               |
| 1867.프로세서 연결하기   [<문제보기>](#프로세서-연결하기)    | SWEA      |                           |
| 1949.등산로조성                [<문제보기>](#등산로-조성)    | SWEA      | DFS                       |
| 1953.탈주범검거                [<문제보기>](#탈주범-검거)    | SWEA      | DFS, 이동조건             |
| [1952.수영장](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq)                        [<문제보기>](#수영장) | SWEA      | 백트래킹                  |
| 2382.미생물격리                [<문제보기>](#미생물격리)     | SWEA      |                           |
| 2105.디저트 카페                [<문제보기>](#디저트-카페)   | SWEA      | 백트래킹                  |
| 5650.핀볼 게임                   [<문제보기>](#핀볼-게임)    | SWEA      |                           |
| 5656.벽돌깨기                    [<문제보기>](#벽돌깨기)     | SWEA      |                           |
| 4008. 숫자만들기               [<문제보기>](#숫자만들기)     | SWEA      | 백트래킹                  |
| 1861. 정사각형 방              [<문제보기>](#정사각형-방)    | SWEA      | DP                        |
| 1865. 동철이의 일 분배     [<문제보기>](#동철이의-일-분배)   | SWEA      | 백트래킹                  |
| 2819. 격자판의 숫자 이어붙이기 [<문제보기>](#격자판의-숫자-이어붙이기) | SWEA      | 완전탐색                  |
| 3752.가능한 시험점수       [<문제풀이>](#가능한-시험점수)    | SWEA      | 생각?                     |
| 1486.장훈이의 높은 선반  [<문제풀이>](#장훈이의-높은-선반)   | SWEA      | 백트래킹                  |
| 1249.보급로                       [<문제풀이>](#보급로)      | SWEA      | 메모이제이션              |
| --------------------------------                             | --------- | -----------               |
| 그 외                                                        |           |                           |
| 2611.좋은수열                    [<문제보기>](#좋은수열)     | BOJ       |                           |
| 12871.무한문자열              [<문제보기>](#무한-문자열)     | BOJ       |                           |
| 1032.명령 프롬프트           [<문제보기>](#명령-프롬프트)    | BOJ       |                           |
| 3079.입국심사                   [<문제보기>](#입국심사)      | BOJ       | 파라메트릭 서치(이분탐색) |
| 1149.RGB거리                   [<문제보기>](#RGB거리)        | BOJ       |                           |
| 2178.미로 탐색                  [<문제보기>](#미로-탐색)     | BOJ       | BFS                       |

[BOJ12100]: https://www.acmicpc.net/problem/12100
[BOJ14503]: https://www.acmicpc.net/problem/14503
[BOJ16235]: https://www.acmicpc.net/problem/16235
[BOJ17837]: https://www.acmicpc.net/problem/17837
[BOJ17142]: https://www.acmicpc.net/problem/17142
[BOJ2146]: https://www.acmicpc.net/problem/2146
[BOJ17472]: https://www.acmicpc.net/problem/17472
[BOJ2644]: https://www.acmicpc.net/problem/2644
[BOJ2479]: https://www.acmicpc.net/problem/2479
[BOJ1726]: https://www.acmicpc.net/problem/1726
[BOJ10711]: https://www.acmicpc.net/problem/10711


[BOJ2667]: https://www.acmicpc.net/problem/2667
[BOJ2468]: https://www.acmicpc.net/problem/2468
[BOJ2636]: https://www.acmicpc.net/problem/2636
[BOJ2573]: https://www.acmicpc.net/problem/2573
[BOJ2589]: https://www.acmicpc.net/problem/2589
[BOJ16234]: https://www.acmicpc.net/problem/16234
[BOJ14889]: https://www.acmicpc.net/problem/14889
[BOJ14501]: https://www.acmicpc.net/problem/14501
[BOJ15686]: https://www.acmicpc.net/problem/15686
[BOJ14888]: https://www.acmicpc.net/problem/14888
[BOJ14502]: https://www.acmicpc.net/problem/14502
[BOJ17070]: https://www.acmicpc.net/problem/17070
[BOJ15683]: https://www.acmicpc.net/problem/15683
[BOJ17471]: https://www.acmicpc.net/problem/17471
[BOJ17135]: https://www.acmicpc.net/problem/17135



## 단지번호붙이기 [목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74249787-10dce300-4d2d-11ea-8f2d-ce57f7f5855b.png)





```python
# DFS (1)
# result 리스트를 만들어서 단지 수 추가
# len(result) 출력하고
# result 를 오름차순 정렬한 후 print

dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]

def dfs(x, y):
    global cnt
    # 방문했으면 그 지점은 0으로 변경
    arr[x][y] = 0
    visit[x][y] = True
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        # 경계조건 + 방문조건 + 맵에서의 위치 값 == 1
        if 0 <= nx < N and 0 <= ny < N and not visit[nx][ny] and arr[nx][ny] == 1:
            cnt += 1
            dfs(nx, ny)
    return cnt

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
# print(arr)

visit = [[False]*N for _ in range(N)]
res = []
# 1인 지점을 만났을 때 그 지점을 개수에 포함시켜야 하므로
# cnt = 1로 시작한다.
cnt = 1
for i in range(N):
    for j in range(N):
        # 맵은 하나로 고정 되어있기 때문에
        # not visit으로 끊어낼 수 있다
        if arr[i][j] == 1 and not visit[i][j]:
            dfs(i, j)
            res.append(cnt)
            cnt = 1

# .sort()는 변경사항이 저장됨
res.sort()
print(len(res))
for i in res:
    print(i)
```





## 안전영역

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74350254-cfb20500-4df8-11ea-8ef5-e6fb9998c853.png)





```python
# pypy 말고 python3로 제출해야됨
import sys
sys.setrecursionlimit(10000)

def dfs(x, y):
    visit[x][y] = True
    # 아래 배열을 돌 때 i, j를 사용했기 때문에
    # 다른 변수 k 를 사용하는 것이 안전하다
    for k in range(4):
        nx, ny = x+dx[k], y+dy[k]
        if 0 <= nx < N and 0 <= ny < N:
            if arr[nx][ny] > height and not visit[nx][ny]:
                dfs(nx, ny)


N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

# 섬의 높이 범위내에서 판단하면됨
# 최소값, 최대값을 미리 찾아두고 범위를 좁히는데 사용
Max_h, Min_h = 0, 100
for i in range(N):
    for j in range(N):
        if Max_h <= arr[i][j]: Max_h = arr[i][j]
        if Min_h >= arr[i][j]: Min_h = arr[i][j]

# <<중요>> 모든 지역이 안전지역인 경우 그룹 수 : 1
Max = 1

# 높이의 최소값, 최대값 범위를 돌며 Max 뽑아냄
for height in range(Min_h, Max_h+1):
    cnt = 0
    visit = [[False] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if height < arr[i][j] and not visit[i][j]:
                cnt += 1
                dfs(i, j)

    if Max <= cnt:
        Max = cnt

print(Max)
```





## 치즈

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75030254-0ff34080-54e7-11ea-8fda-1ad6f33e36ec.png)



```python
import sys; sys.stdin = open('txt/2636_치즈.txt', 'r')
from pprint import pprint
import collections
sys.setrecursionlimit(10000)

# 외부 공기인 경우 'o'로 바꾸는 작업
def dfs(a, b):
    visit[a][b] = True
    arr[a][b] = 'o'
    for l in range(4):
        na, nb = a+dx[l], b+dy[l]
        if 0 <= na < N and 0 <= nb < M:
            if (arr[na][nb] == 0 or arr[na][nb] == 'o') and not visit[na][nb]:
                dfs(na, nb)

# 주변에 외부 공기가 있으면 테두리 치즈('c')로 변경
def find(x, y):
    global cnt
    visit[x][y] = True
    for k in range(4):
        nx, ny = x+dx[k], y+dy[k]
        if arr[nx][ny] == 'o':
            arr[x][y] = 'c'
            return

N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
result = []

time = 0
while True:
    one = 0
    for find_one in arr:
        one += find_one.count(1)
    result.append(one)
    # print(result)

    visit = [[False] * M for _ in range(N)]
    # 테두리가 만들어져 있기 때문에 (0, 0)에서 시작
    dfs(0, 0)

    # 모두 공기로 바뀌었을 때 종료
    cnt = 0
    for lst in arr:
        cnt += lst.count('o')
    if cnt == N * M: break

    # 공기와 맞닿은 치즈인지
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 1:
                find(i, j)

    # 공기와 맞닿은 치즈인 경우
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 'c':
                arr[i][j] = 'o'

    # 모든 작업이 끝난 후 시간 + 1
    time += 1

print(time)
print(result[-2])
```





## 미세먼지 안녕! 

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78500786-78df0100-7793-11ea-8576-a7a50bbf6fe1.png)



```python
def diffuse():
    moving_dust = [[0]*c for _ in range(r)]
    for i in range(r):
        for j in range(c):
            if arr[i][j] >= 5:
                center_dust = arr[i][j] // 5
                for dx, dy in (-1,0), (1,0), (0,1), (0,-1):
                    nx, ny = i+dx, j+dy
                    if 0 <= nx < r and 0 <= ny < c and arr[nx][ny] != -1:
                        moving_dust[nx][ny] += center_dust
                        arr[i][j] -= center_dust
    for i in range(r):
        for j in range(c):
            arr[i][j] += moving_dust[i][j]

def purify():
    # 위쪽 회전(반시계 방향)
    for i in range(upper-2, -1, -1):
        arr[i+1][0] = arr[i][0]
    for i in range(c-1):
        arr[0][i] = arr[0][i+1]
    for i in range(upper):
        arr[i][c-1] = arr[i+1][c-1]
    for i in range(c-2, -1, -1):
        arr[upper][i+1] = arr[upper][i]
    # 정화
    arr[upper][1] = 0
    
    # 아래쪽(시계 방향) 
    for i in range(lower+1, r-1):
        arr[i][0] = arr[i+1][0]
    for i in range(c-1):
        arr[r-1][i] = arr[r-1][i+1]
    for i in range(r-2, lower-1, -1):
        arr[i+1][c-1] = arr[i][c-1]
    for i in range(c-2, -1, -1):
        arr[lower][i+1] = arr[lower][i]
    # 정화
    arr[lower][1] = 0


for _ in range(int(input())):
    r, c, t = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(r)]
    upper, lower = -1, 0

    for i in range(r):
        if arr[i][0] == -1:
            upper2 = i-1
            lower2 = i
            if upper == -1:
                upper = i
            else:
                lower = i

    for _ in range(t):
        diffuse()
        purify()
#    print('upper: ', upper)
#    print('lower: ', lower)
#    print('upper2: ', upper2)
#    print('lower2: ', lower2)
    print(sum(map(sum, arr)) + 2)
```







## 색종이 붙이기 

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74669227-11bcbb80-51ea-11ea-8bfb-dbf8e7d40bb8.png)



**문제 잘 읽고 조건 빼먹으면 안됨

```python
def dfs(depth):
    global Min, cnt_one

    # 이미 최소값보다 depth가 커지면 더이상 탐색 안하고 리턴
    if Min > 0 and Min <= depth:
        return

    # 남은 1이 없을 때 depth가 최소값보다 작다면(최초에 answer는 -1)
    if cnt_one == 0:
        if Min == -1 or Min > depth:
            Min = depth  # 값을 할당하고 리턴
        return

    # 1이 있는곳에서 시작(좌상단)
    for x in range(10):
        for y in range(10):
            if MAP[x][y]:
                break
        if MAP[x][y]:
            break

    # 끝까지 갔는데 그 자리가 0이면 조사할 필요없음
    if x == 9 and y == 9 and MAP[x][y] == 0: return

    # 해당 점에 1~5 사이즈를 대본다.
    for size in range(1, 5 + 1):
        # 종이가 남아있을 때 진행
        if paper[size]:
            one_zero = []  # 1 에서 0으로 바뀐 좌표 저장해서 나중에 도로 바꿔준다.

            if isCoverable(x, y, size):  # 해당 사이즈로 덮을 수 있다면
                # 색종이로 덮어지는 부분을 0으로 변경
                for next_x in range(x, x + size):
                    for next_y in range(y, y + size):
                        MAP[next_x][next_y] = 0  # 1에서 0 으로 바꾸고
                        one_zero.append((next_x, next_y))  # 좌표를 저장

                # 색종이가 붙여졌기 때문에 넓이만큼 1의 개수가 줄어듦
                cnt_one -= size ** 2
                paper[size] -= 1
                dfs(depth + 1)
                # 다시 탐색하기 위해 값을 되돌림
                paper[size] += 1
                cnt_one += size ** 2

            # 바뀐 좌표들을 다시 0에서 1로 바꿔줌
            for x_y in one_zero:
                MAP[x_y[0]][x_y[1]] = 1


# 색종이로 채울 수 있는지 검사
def isCoverable(x, y, size):
    for i in range(x, x + size):
        for j in range(y, y + size):
            if i < 10 and j < 10:
                # 0인 곳에는 색종이가 붙으면 안된다. **** 문제 조건 잘 읽기!
                if MAP[i][j] == 0:
                    return False
            # 색종이가 MAP 범위를 벗어나면 안된다.
            else:
                return False
    return True

for _ in range(int(input())):
    MAP = [list(map(int, input().split())) for _ in range(10)]
    paper = [0, 5, 5, 5, 5, 5]
    Min = -1
    cnt_one = sum(sum(m) for m in MAP)
    dfs(0)
    print(Min)
```



## 빙산

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/79636426-7ed0db00-81b2-11ea-883e-d250177e8d45.png)



```python
import sys
from collections import deque
def bfs(x, y, visit):
    q = deque()
    q.append((x, y))
    melting_que = deque()
    visit[x][y] = True
    # q: 검사할 빙산
    # 빙산을 추가하면서 주변에 물이 있는지 함께 검사
    while q:
        x, y = q.popleft()
        melt_cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < Row and 0 <= ny < Col and not visit[nx][ny]:
                # 빙산의 높이가 있을 경우 검사할 빙산에 추가
                if arr[nx][ny] != 0:
                    visit[nx][ny] = True
                    q.append((nx, ny))
                # 주변에 물이 있으면 cnt += 1
                else:
                    melt_cnt += 1
        
        # 녹는 빙산 추가
        if melt_cnt:
            melting_que.append((x, y, melt_cnt))

    # 빙산 녹이기
    while melting_que:
        # x좌표, y좌표, 녹는 양
        x, y, melt_cnt = melting_que.popleft()
        arr[x][y] = max(arr[x][y] - melt_cnt, 0)

    # return

Row, Col = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(Row)]
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

year = 0
while True:
    cnt = 0
    visit = [[False] * Col for _ in range(Row)]
    for i in range(1, Row-1):
        for j in range(1, Col-1):
            if arr[i][j] != 0 and visit[i][j] == 0:
                cnt += 1
                bfs(i, j, visit)


    # 빙산의 갯수가 0이거나 2이상일 경우 반복문 종료
    if cnt == 0:
        year = 0
        break
    if cnt >= 2:
        break

    # 다 돌았는데 안끝났으면 year += 1
    year += 1

print(year)
```





## 보물섬

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75251343-c0ca4a00-581d-11ea-9f72-8f4ee873b30e.png)



```python
import collections

# 모든 'L'을 돌면서 각 자리에서 가장 멀리 있는 'L'까지의 거리를 구하고
# 그 거리들 중 최대값을 구하는 문제
dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]

# bfs로 풀어야 이동 거리를 알 수 있음
def bfs(x, y, d):
    Max = 0
    visit[x][y] = True
    Q = collections.deque()
    Q.append((x, y, d))
    while Q:
        x, y, d = Q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and arr[nx][ny] == 'L':
                # pop해 온 자리에서 이동할 수 있으면 d+1
                Q.append((nx, ny, d+1))
                visit[nx][ny] = True
        Max = max(Max, d)
    return Max

N, M = map(int, input().split())
arr = [list(input()) for _ in range(N)]

ans = 0
for i in range(N):
    for j in range(M):
        # 모든 'L'을 돌며 탐색
        if arr[i][j] == 'L':
            visit = [[False]*M for _ in range(N)]
            ans = max(bfs(i, j, 0), ans)


print(ans)
```



## 인구이동

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75415907-5f66c000-5970-11ea-87e2-9814c0025850.png)



```python
import collections

def bfs(map, a, b):
    q = collections.deque()
    union = set()
    q.append((a, b))
    while q:
        x, y = q.popleft()
        visit[x][y] = True
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            # 경계조건 + 방문확인
            if 0 <= nx < N and 0 <= ny < N and not visit[nx][ny]:
                # 국경선 open/close 조건
                if L <= abs(map[x][y] - map[nx][ny]) <= R:
                    # set.update(리스트) : 없는 항목만 set에 추가
                    union.update([(x, y), (nx, ny)])
                    q.append((nx, ny))
    return union


dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

for _ in range(int(input())):
    N, L, R = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    day = 0
    while True:
        visit = [[False]*N for _ in range(N)]
        results = []
        for i in range(N):
            for j in range(N):
                if not visit[i][j]:
                    results.append(bfs(arr, i, j))

        # total = 0 을 여기에 두고 돌리는 실수를 해서 계속 틀림
        for result in results:
            total = 0
            if result:
                # 연합국 안에서 평균값 구하고
                for arr, b in result:
                    total += arr[arr][b]
                avg = total // len(result)
                
                # 국가별 인구를 평균값으로 변경
                for arr, b in result:
                    arr[arr][b] = avg

        # 인구이동 종료조건
        if len(results) == N*N: break

        day += 1
    print(day)
```





## 스타트와 링크

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75406860-e9089480-5954-11ea-8c78-c07c20ea060b.png)



```python
from itertools import combinations

for _ in range(int(input())):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    member = list(range(N))

    Min = 999999    
    # 팀을 두 개로 나누기 (조합)
    for group1 in combinations(member, N // 2):
        group2 = list(set(member) - set(group1))

        # 1팀, 2팀 능력치 계산
        team_1, team_2 = 0, 0
        for i, j in combinations(group1, 2):
            team_1 += arr[i][j] + arr[j][i]
        for i, j in combinations(group2, 2):
            team_2 += arr[i][j] + arr[j][i]
        Min = min(Min, abs(team_1 - team_2))

    print(Min)
```





## 연구소

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75025092-e2ee6000-54dd-11ea-9dd2-a4b44e634c03.png)



```python
import itertools
import collections
import copy
from pprint import pprint
# bfs : 964 ms
# dfs : 1340 ms

dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

def bfs(x, y):
    Q = collections.deque()
    Q.append((x, y))
    while Q:
        x, y = Q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and copied_arr[nx][ny] == 0:
                copied_arr[nx][ny] = 2
                visit[nx][ny] = True
                Q.append((nx, ny))

def dfs(x, y):
    visit[x][y] = True
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and copied_arr[nx][ny] == 0:
            copied_arr[nx][ny] = 2
            visit[nx][ny] = True
            dfs(nx, ny)


for _ in range(int(input())):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 바이러스와 빈칸의 좌표 저장
    virus = []
    place = []
    for i in range(N):
        for j in range(M):
            if arr[i][j] == 2:
                virus.append((i, j))
            elif arr[i][j] == 0:
                place.append((i, j))

    Max = 0
    # 빈 칸들 중 3개 뽑는 조합
    for comb in itertools.combinations(place, 3):
        # 각 경우마다 맵 새로해줌
        copied_arr = copy.deepcopy(arr)
        visit = [[False] * M for _ in range(N)]
        # 벽 세우기
        for x, y in comb:
            copied_arr[x][y] = 1

        # 바이러스 퍼뜨리기
        for x, y in virus:
            bfs(x, y)
            # dfs(x, y)

        # 바이러스 안퍼진 곳 개수 카운트
        cnt = 0
        for i in range(N):
            for j in range(M):
                if copied_arr[i][j] == 0:
                    cnt += 1

        Max = max(Max, cnt)

    print(Max)
```



## 퇴사

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75701737-9d107380-5cf7-11ea-8430-1bd85c23b400.png)



```python
for _ in range(int(input())):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    compare = [0] * N

    for i in range(N):
        if i + arr[i][0] <= N:
            compare[i] = arr[i][1]
            for j in range(i):
                # 날짜 범위 안에서
                if j + arr[j][0] <= i:
                    # i번까지 올 때 최대 = max(i번의 크기 vs i번까지의 합)
                    compare[i] = max(compare[i], compare[j] + arr[i][1])
    print(max(compare))
```





## 치킨배달

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75611652-c1d1e300-5b5f-11ea-8f9d-4c3e7f578beb.png)



```python
# 치킨집 하나에 여러집이 연결될 수 있다.
from itertools import combinations

for _ in range(int(input())):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    home = []
    chicken = []
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 1:
                home.append((i, j))
            elif arr[i][j] == 2:
                chicken.append((i, j))
    
    ans = 0xfffffff
    for chick in combinations(chicken, M):
        # 각 경우마다 res값 0부터 시작
        res = 0
        for home_x, home_y in home:
            Min = 0xfffffff
            # 각 집에서 가장 가까운 치킨집 거리 저장
            for chick_x, chick_y in chick:
                Min = min(Min, abs(home_x-chick_x)+abs(home_y-chick_y))
            res += Min
        ans = min(res, ans)
    
    print(ans)
```





## 연산자 끼워넣기

[목록](#목록)



![image](https://user-images.githubusercontent.com/52685247/75352880-cc854180-58ed-11ea-9bdd-edce0cbec8c2.png)



```python
def cal(idx, val, plus, minus, mul, div):
    global Max, Min
    if idx == N:
        Max = max(Max, val)
        Min = min(Min, val)

    if plus:
        cal(idx + 1, val + nums[idx], plus - 1, minus, mul, div)
    if minus:
        cal(idx + 1, val - nums[idx], plus, minus - 1, mul, div)
    if mul:
        cal(idx + 1, val * nums[idx], plus, minus, mul - 1, div)
    if div:
        cal(idx + 1, int(val / nums[idx]), plus, minus, mul, div - 1)

for _ in range(int(input())):
    N = int(input())
    nums = list(map(int, input().split()))
    plus, minus, mul, div = map(int, input().split())

    Max = -999999999
    Min = 999999999
    cal(1, nums[0], plus, minus, mul, div)
    print(Max)
    print(Min)
```



## 게리맨더링

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/76139154-12ca6580-6091-11ea-9f94-34f16c4d13a8.png)



```python
from itertools import combinations

def dfs(start, group):
    visit[start] = True
    for way in G[start]:
        if way in group and not visit[way]:
            dfs(way, group)

for tc in range(int(input())):
    N = int(input())
    people = [0] + list(map(int, input().split()))
    G = [[] for _ in range(N+1)]
    for i in range(1, N+1):
        G[i] = list(map(int, input().split()))[1:]
    # print(G)
    arr = list(range(1, N+1))
    Min = 0xffffff
    # 두 그룹으로 나누기
    # k: 첫 그룹에 몇 개를 넣을지
    for k in range(1, N//2+1):
        for comb in combinations(arr, k):
            A = list(comb)
            B = []
            for i in arr:
                if i not in A:
                    B.append(i)
            # print(A, B)
            
            # 모두 방문했으면 모두 연결 가능한 상태이다.
            visit = [False for _ in range(N+1)]
            dfs(A[0], A)
            if len(A) != visit.count(True): continue

            visit = [False for _ in range(N+1)]
            dfs(B[0], B)
            if len(B) != visit.count(True): continue

            sum_A, sum_B = 0, 0
            for i in A:
                sum_A += people[i]
            for i in B:
                sum_B += people[i]
            Min = min(Min, abs(sum_A-sum_B))
            
    # 두 그룹으로 나눌 수 없다 == Min 값이 변하지 않았다
    print(-1 if Min == 0xffffff else Min)
```





## 감시

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78900686-29aa1080-7ab2-11ea-8731-d415d18f99b5.png)

```python
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

dir = [0,
       [[0], [1], [2], [3]],
       [[0, 1], [2, 3]],
       [[0, 3], [0, 2], [1, 3], [1, 2]],
       [[0, 1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 3]],
       [[0, 1, 2, 3]]
       ]


def watch(x, y, lst, val):
    for d in lst:
        nx, ny = x+dx[d], y+dy[d]
        # 경계조건 + 벽이 아닌 조건
        while 0 <= nx < N and 0 <= ny < M and arr[nx][ny] != 6:
            visit[nx][ny] += val
            nx, ny = nx+dx[d], ny+dy[d]


def backtrack(k, s):
    global Min
    if k == s:
        cnt = 0
        for i in range(N):
            for j in range(M):
                # watch가 끝난 후 그 자리가 0이고, 방문한 적 없는 경우에만 count
                if not visit[i][j] and arr[i][j] == 0:
                    cnt += 1
        Min = min(Min, cnt)
    else:
        # 카메라 위치와 카메라 번호 가져옴
        x, y, d = cctv[k]
        # 카메라 종류에 따라 볼 수 있는 방향 모두 체크
        for lst in dir[d]:
            watch(x, y, lst, 1)
            backtrack(k+1, s)
            watch(x, y, lst, -1)

for _ in range(int(input())):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    # 카메라 종류 리스트에 담아둠
    cctv = []
    for i in range(N):
        for j in range(M):
            if 0 < arr[i][j] < 6: cctv.append((i, j, arr[i][j]))

    # 한 번이라도 지나갔으면 0보다 크게됨
    Min = 0xfffff
    visit = [[0]*M for _ in range(N)]
    backtrack(0, len(cctv))
    print(Min)
```





## 로봇청소기

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/74440063-a785dd00-4eb0-11ea-8e9e-3e862370d954.png)





```python
# 북 동 남 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def clean(x, y, d, cnt):
    visit[x][y] = True
    # 왼쪽 방향으로 돌아야하니
    # dx, dy 작성한 것의 반대 방향으로 돌아야 함
    for i in range(-3, 1):
        ndir = (d-i)%4
        nx = x+dx[ndir]
        ny = y+dy[ndir]
        # 진행하는 방향이 청소할 수 있는 곳이면
        # 이동해서 청소 (위치, 방향 바꾸고 cnt+1)
        if 0 <= nx < N and 0 <= ny < M:
            if not arr[nx][ny] and not visit[nx][ny]:
                clean(nx, ny, ndir, cnt+1)
                return

    # 네 방향 다 체크하며 clean이 모두 동작한 후
    # 처음 보던 방향의 반대(-) 방향 체크
    # 뒤쪽 방향이 벽이라면 끝낸다
    if arr[x-dx[d]][y-dy[d]]:
        print(cnt)
        return
    # 벽이 아니라면 방향 그대로하고 위치만 뒤로(후진)
    else:
        clean(x-dx[d], y-dy[d], d, cnt)
    
    # 뒤쪽 확인하는 약간 무식한 방법 
    # if arr[x+dx[(d+2)%4]][y+dy[(d+2)%4]]:
    #     return
    # else:
    #     clean(x+dx[(d+2)%4], y+dy[(d+2)%4], d)


for _ in range(int(input())):
    N, M = map(int, input().split())
    loc_x, loc_y, head = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    visit = [[False]*M for _ in range(N)]
    # 현재 위치 청소하기 때문에 cnt = 1 부터 시작
    clean(loc_x, loc_y, head, 1)
```

 

## 2048

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78500803-93b17580-7793-11ea-876f-abc3fca688c2.png)



```python
from collections import deque
from copy import deepcopy

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
ans = 0
q = deque()

def add(i, j):
    # 값이 있으면 큐에 넣고 그 자리는 0
    if arr[i][j]:
        q.append(arr[i][j])
        arr[i][j] = 0

def merge(i, j, di, dj):
    while q:
        x = q.popleft()
        # 비교하는 칸이 0이면 그 자리에 넣는다(자리 채우기)
        if arr[i][j] == 0:
            arr[i][j] = x
        # 값이 같으면 합침
        elif arr[i][j] == x:
            arr[i][j] *= 2
            i, j = i+di, j+dj
        # 값이 다르면 그대로 넣고 i, j만 수정
        else:
            arr[i+di][j+dj] = x
            i, j = i+di, j+dj


def move(i):
    # 위로 밈
    if i == 0:
        for j in range(N):
            for i in range(N):
                add(i, j)
            # di += 1로 위에서 아래로가면서 검사
            merge(0, j, 1, 0)
    # 아래로 밈
    elif i == 1:
        for j in range(N):
            for i in range(N-1, -1, -1):
                add(i, j)
            merge(N-1, j, -1, 0)
    # 왼쪽으로 밈
    elif i == 2:
        for i in range(N):
            for j in range(N):
                add(i, j)
            merge(i, 0, 0, 1)
    # 오른쪽으로 밈
    else:
        for i in range(N):
            for j in range(N-1, -1, -1):
                add(i, j)
            merge(i, N-1, 0, -1)



def solve(cnt):
    global ans, arr
    if cnt == 5:
        for i in range(N):
            ans = max(ans, max(arr[i]))
            # print(arr)
        return

    box = deepcopy(arr)
    for i in range(4):
        move(i)
        solve(cnt+1)
        arr = deepcopy(box)

solve(0)
print(ans)
```









## 촌수계산

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/76139887-32b15780-6098-11ea-9b1b-2549163cd12a.png)



```python
import collections

def bfs(v):
    q = collections.deque()
    visit = [False]*(n+1)
    q.append(v)
    visit[v] = True
    level = 0
    while q:
        for _ in range(len(q)):
            v = q.popleft()
            if v == end:
                return level
            for e in G[v]:
                if not(visit[e]):
                    visit[e] = True
                    q.append(e)
        level += 1
    return -1

n = int(input())
start, end = map(int, input().split())
m = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(m):
    arr, b = map(int, input().split())
    G[arr].append(b)
    G[b].append(arr)

print(bfs(start))
```



## 등산로 조성

[목록](#목록)



```python
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

def move(x, y, cnt, chance):
    global Max
    visit[x][y] = True
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < N and 0 <= ny < N and not visit[nx][ny]:
            # 높이가 낮아서 진행할 수 있으면 dfs 전진
            if arr[nx][ny] < arr[x][y]:
                move(nx, ny, cnt+1, chance)

            # 전진할 수 없을 때 기회가 남아있으면
            elif chance:
                for cut in range(1, K+1):
                    if arr[nx][ny] - cut < arr[x][y]:
                        arr[nx][ny] -= cut
                        move(nx, ny, cnt+1, 0)
                        # dfs 끝까지 다 가봤으면 원상복구
                        arr[nx][ny] += cut
                        break

    if Max < cnt: Max = cnt
    visit[x][y] = False

for tc in range(1, int(input())+1):
    N, K = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    # print(arr)

    high = 0
    for i in range(N):
        high = max(high, max(arr[i]))
    # print(Max)

    cand = []
    for i in range(N):
        for j in range(N):
            if arr[i][j] == high:
                cand.append((i, j))
    # print(cand)
    visit = [[False]*N for _ in range(N)]
    chance = 1
    Max = 0
    for x, y in cand:
        move(x, y, 1, 1)

    print('#{} {}'.format(tc, Max))
    # break
```







## 탈주범 검거

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/76542234-09ddf780-64c8-11ea-8a2e-aea98a3fb413.png)



```python
import collections

def move(r, c, t):
    global cnt
    Q = collections.deque()
    Q.append((r, c, t))
    visit[r][c] = True
    while Q:
        rr, cc, tt = Q.popleft()
        # 제한 시간 안에서만 돌도록
        if tt < L:
            # 현재 위치에서의 파이프의 방향
            for a, b in pipe[arr[rr][cc]]:
                # 경계조건
                if 0 <= rr+a < N and 0 <= cc+b < M:
                    # 탐색하는 위치에 파이프가 없으면 컨티뉴
                    if not arr[rr+a][cc+b]: continue
                    # 탐색하는 위치의 파이프 모양을 보고 이동할 수 있는지 판단
                    if not visit[rr+a][cc+b] and (-1 * a, -1 * b) in pipe[arr[rr+a][cc+b]]:
                        cnt += 1
                        visit[rr+a][cc+b] = True
                        Q.append((rr+a, cc+b, tt+1))

for tc in range(1, int(input())+1):
    N, M, R, C, L = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 파이프별로 이동할 수 있는 방향을 저장
    pipe = {
        1: [(0, -1), (0, 1), (-1, 0), (1, 0)],
        2: [(-1, 0), (1, 0)],
        3: [(0, -1), (0, 1)],
        4: [(-1, 0), (0, 1)],
        5: [(1, 0), (0, 1)],
        6: [(1, 0), (0, -1)],
        7: [(-1, 0), (0, -1)]
    }

    visit = [[False]*M for _ in range(N)]
    cnt = 1
    move(R, C, 1)
    print(cnt)
```







## 수영장

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75517419-f9e30400-5a41-11ea-8277-e5cb52ea22cb.png)



```python
def swim(price, date):
    global Min
    # 마지막 한 달이 남았더라도 세 달치가 더 저렴하다면
    # 세 달치로 결제할 수 있음
    # ==> date가 12를 넘어도 됨
    if date >= 12:
        Min = min(Min, price)
        return

    # 해당하는 달에 이용 계획이 없으면 다음달로 넘어감
    if not schedule[date]:
        swim(price, date+1)

    # 이용 계획이 있는 경우 백트래킹 진행
    else:
        swim(price + day*schedule[date], date+1)
        swim(price + month, date+1)
        swim(price + month_3, date+3)

for tc in range(1, int(input())+1):
    day, month, month_3, year = list(map(int, input().split()))
    schedule = list(map(int, input().split()))

    # 일년치 결제하는 것보다 더 많이 나올 수 없음
    Min = year
    swim(0, 0)

    print('#{} {}'.format(tc, Min))
```



## 디저트 카페

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/76915040-5d54a900-68ff-11ea-9c24-b9f6f9bc4c9c.png)



```python
dir = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
def find(x, y, cnt, check):
    global Max
    if cnt == 4: return

    nx, ny = x+dir[cnt][0], y+dir[cnt][1]
    if 0 <= nx < N and 0 <= ny < N:
        if nx == i and ny == j and Max <= len(check):
            Max = len(check)
            return

        if cafes[nx][ny] not in check:
            check.append(cafes[nx][ny])
            find(nx, ny, cnt, check)
            find(nx, ny, cnt+1, check)
            check.pop()


for tc in range(1, int(input())+1):
    N = int(input())
    cafes = [list(map(int, input().split())) for _ in range(N)]

    Max = -1
    for i in range(N):
        for j in range(N):
            check = []
            find(i, j, 0, [cafes[i][j]])

    print('#{} {}'.format(tc, Max))
```





## 숫자만들기

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75648739-550c3500-5c94-11ea-8a62-26a3929767b9.png)



```python
def cal(res, cnt, plus, minus, mul, div):
    global Max, Min
    if cnt == N:
        Max = max(Max, res)
        Min = min(Min, res)

    if plus:
        cal(res+arr[cnt], cnt+1, plus-1, minus, mul, div)
    if minus:
        cal(res-arr[cnt], cnt+1, plus, minus-1, mul, div)
    if mul:
        cal(res*arr[cnt], cnt+1, plus, minus, mul-1, div)
    if div:
        cal(int(res/arr[cnt]), cnt+1, plus, minus, mul, div-1)


for tc in range(1, int(input())+1):
    N = int(input())
    plus, minus, mul, div = map(int, input().split())
    arr = list(map(int, input().split()))

    Max = -999999999
    Min = 999999999
    cal(arr[0], 1, plus, minus, mul, div)
    print(f'#{tc} {Max-Min}')
```





## 정사각형 방

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75756362-dedeff80-5d73-11ea-8669-d1d2a66aff47.png)



```python
for tc in range(1, int(input())+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    
    # 정답 후보들을 배열에 저장한다고 생각
    ans = [0 for _ in range(N**2)]

    dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]
    for i in range(N):
        for j in range(N):
            for k in range(4):
                nx, ny = i+dx[k], j+dy[k]
                # 이동할 수 있으면 1을 저장
                if 0 <= nx < N and 0 <= ny < N and arr[i][j] + 1 == arr[nx][ny]:
                    ans[arr[i][j]] = 1
                    # 그 방향으로 이동할 수 있으면 다른 방향은 검색할 필요 없음.
                    # 배열안의 모든 값은 서로 다른 값이기 때문
                    break

    # 시작점을 출력하기 위해 뒤에서부터 탐색
    for i in range(N**2-1, -1, -1):
        # 이동할 수 있는 값이 연속된다면 값을 누적해간다
        if ans[i] and ans[i-1]:
            ans[i-1] += ans[i]

    # .index를 하면 해당하는 값 중 index값이 작은 것을 출력한다.
    print('#{} {} {}'.format(tc, ans.index(max(ans)), max(ans)+1))
```



## 동철이의 일 분배

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75863512-f4235f00-5e43-11ea-8859-17042969419a.png)



```python
def distrib(row):
    global Max, res

    # 다 돌았으면 확률 계산
    if row == N:
        Max = max(Max, res)
        return

    # 이미 확률이 더 낮아진 경우, 더 진행할 필요없음
    if Max > res: return

    # row를 돌며 모든 경우의 col을 순회(순열)
    for col in range(N):
        # 방문한 곳이거나 + 확률 0이면 안감
        if check[col] or not arr[row][col]: continue
        check[col] = 1
        res *= arr[row][col]
        distrib(row+1)
        check[col] = 0
        res /= arr[row][col]

for tc in range(1, int(input())+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 확률로 처리해주는 과정
    for i in range(N):
        for j in range(N):
            arr[i][j] /= 100

    check = [0 for _ in range(N)]
    Max = 0
    res = 1
    distrib(0)
    print('#{} {:.6f}'.format(tc, Max*100))
```



## 격자판의 숫자 이어붙이기

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75940038-48275580-5ecf-11ea-8b46-01c1e23b49b0.png)



```python
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

def find(x, y, word):
    if len(word) == 7:
        nums.add(word)
        return

    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < 4 and 0 <= ny < 4:
            find(nx, ny, word+str(arr[nx][ny]))

for tc in range(1, int(input())+1):
    arr = [list(map(int, input().split())) for _ in range(4)]
    nums = set()

    for i in range(4):
        for j in range(4):
            find(i, j, str(arr[i][j]))

    print('#{} {}'.format(tc, len(nums)))
```





## 가능한 시험점수

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/76051899-e211ff80-5fae-11ea-848c-600dff4cf021.png)



- 재귀로 풀었을 때 시간초과남

```python
for tc in range(1, int(input())+1):
    N = int(input())
    nums = list(map(int, input().split()))
    candi = [1] + [0] * sum(nums)
    ans = 0
    for i in range(N):
        ans += nums[i]
        for j in range(ans, -1, -1):
            if candi[j]:
                candi[j+nums[i]] = 1

    print('#{} {}'.format(tc, candi.count(1)))
    
    
--------------------------2---------------------------
for tc in range(1, int(input())+1):
    N = int(input())
    nums = list(map(int, input().split()))
    s = {0}
    while nums:
        tmp = nums.pop(0)
        ss = list(s)
        for i in ss:
            s.add(i+tmp)
    print('#{} {}'.format(tc, len(s)))
```



- 아이디어

![image](https://user-images.githubusercontent.com/52685247/76051625-c149aa00-5fae-11ea-9ca1-205ee3bc2619.png)





## 장훈이의 높은 선반

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/77061815-34770580-6a1e-11ea-8385-b9e6ec832d99.png)



```python
# 모든 경우의 가지치기를 해보고 최소값을 출력
def find(height, num):
    # 선반의 물건을 꺼낼 수 있는 높이라면 result에 추가
    if height >= B:
        result.append(height)
    if num == N: return

    # 더하고 진행
    find(height+arr[num], num+1)
    # 더하지 않고 진행
    find(height, num+1)

for tc in range(1, int(input())+1):
    N, B = map(int, input().split())
    arr = list(map(int, input().split()))
    result = []
    find(0, 0)
    print('#{} {}'.format(tc, min(result)-B))
```





## 보급로

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78989277-26745a80-7b6e-11ea-8337-4119ec373d0d.png)



```python
# 탐색 방향을 오른쪽, 아래 먼저 --> 휴리스틱 최적화
# Main Algorithm : 메모이제이션
from collections import deque

dx, dy = [1, 0, -1, 0], [0, 1, 0, -1]

for tc in range(1, int(input())+1):
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    # print(arr)
    visit = [[-1]* N for _ in range(N)]
    # print(visit)
    visit[0][0] = 0
    q = deque()
    q.append((0, 0))
    while q:
        x, y = q.popleft()
        if x == N-1 and y == N-1: continue
        # 그 위치까지 작업한 양을 cnt로 저장
        cnt = visit[x][y]
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < N:
                # 방문한 적이 없거나, 방문한 기록이 지금 진행 경로값보다 크다면 현재 경로값을 저장
                if visit[nx][ny] == -1 or cnt + arr[nx][ny] < visit[nx][ny]:
                    visit[nx][ny] = cnt + arr[nx][ny]
                    q.append((nx, ny))

    print('#{} {}'.format(tc, visit[N-1][N-1]))
```





## 그 외

## 좋은수열

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/75259822-f9712000-582b-11ea-8337-10c235e51b66.png)



```python
def backtrack(idx):
    # 끝에서 부터 1개, 2개, ...i개씩 비교
    for i in range(1, (idx//2) + 1):
        if num[-i:] == num[2 * (-i):-i]:
            return -1
    
    # 종료조건
    if idx == n:
        for i in range(n):
            print(num[i], end='')
            
        # return 0을 해서 함수를 끝낼 수 있도록 함
        return 0

    # 작은수부터 차례대로 맨 끝에 붙여보고
    # 좋은 수열인지 판단
    for i in range(1, 4):
        num.append(i)
        if backtrack(idx + 1) == 0:
            return 0
        
        # return 이 -1이면 좋은수열이 아님
        num.pop()

n = int(input())
num = []
backtrack(0)
```



```
1211 => 길이 4, 1자리 비교, 나쁜 수열

---------------------------------

1212 => 길이 4, 1자리 비교, 좋은 수열

1212 => 길이 4, 2자리 비교, 나쁜 수열

---------------------------------

123123 => 길이 6, 1자리 비교, 좋은 수열

123123 => 길이 6, 2자리 비교, 좋은 수열

123123 => 길이 6, 3자리 비교, 나쁜 수열
```



## 무한 문자열

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78501766-32d86c00-7798-11ea-97ef-75b1215f63c8.png)

```python
a = input()
b = input()

if a*len(b) == b*len(a):
    print(1)
else:
    print(0)
```



## 명령 프롬프트

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/78502325-97e19100-779b-11ea-96df-91f783ef7ad9.png)

```python
N = int(input())

arr = []
for i in range(N):
    arr.append(input())
# print(arr)

compare = [[] for _ in range(len(arr[0]))]

for word in arr:
    for i in range(len(word)):
        compare[i].append(word[i])
# print(compare)

ans = ''
for words in compare:
    if words.count(words[0]) == len(words):
        ans += words[0]
    else:
        ans += '?'

print(ans)
```



## 입국심사

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/79884977-f90e9300-8430-11ea-9535-1c185101a2ef.png)

```python
# 파라메트릭 서치 알고리즘 적용
# https://sarah950716.tistory.com/16
for _ in range(int(input())):
    # N: 심사대 개수, M: 사람 수
    N, M = map(int, input().split())
    inspect = []
    for _ in range(N):
        inspect.append(int(input()))

    left = 0
    right = M * max(inspect)
    while left <= right:
        mid = (left+right) // 2

        passed = 0
        for time in inspect:
            passed += mid // time

        if passed < M:
            left = mid + 1
        else:
            right = mid - 1

    print(right+1)
```



## RGB거리

[목록](#목록)



![image](https://user-images.githubusercontent.com/52685247/79995439-2ff8ad80-84f2-11ea-94ca-708b689c70c3.png)

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

for i in range(1, N):
    arr[i][0] = min(arr[i-1][1], arr[i-1][2]) + arr[i][0]
    arr[i][1] = min(arr[i-1][0], arr[i-1][2]) + arr[i][1]
    arr[i][2] = min(arr[i-1][0], arr[i-1][1]) + arr[i][2]
    # print(arr)
print(min(arr[N-1]))
```



## 미로 탐색

[목록](#목록)

![image](https://user-images.githubusercontent.com/52685247/80308455-1e711780-880a-11ea-856e-b68742bf03d6.png)

- **DFS로 풀면 시간초과**

```python
import collections

dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

def dfs(x, y, cnt):
    global Min
    if x == N-1 and y == M-1:
        # print(x, y, cnt)
        Min = min(cnt, Min)
        return

    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and arr[nx][ny] == 1:
            visit[nx][ny] = True
            # print(nx, ny, cnt)
            dfs(nx, ny, cnt+1)
            visit[nx][ny] = False

def bfs(x, y, cnt):
    global Min
    q = collections.deque()
    q.append((x, y, cnt))
    while q:
        x, y, cnt = q.popleft()
        if x == N-1 and y == M-1:
            Min = min(Min, cnt)
            break
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 <= nx < N and 0 <= ny < M and not visit[nx][ny] and arr[nx][ny] == 1:
                visit[nx][ny] = True
                q.append((nx, ny, cnt+1))

    return Min



# for _ in range(int(input())):
N, M = map(int, input().split())
arr = [list(map(int, input())) for _ in range(N)]
# print(arr)
visit = [[False] * M for _ in range(N)]
# print(visit)
Min = N*M
# dfs(0, 0, 1)
# print(Min)

print(bfs(0, 0, 1))
```











---

```python
def f(n, k):
    if n==k: # b의 모든 칸이 결정됨
        for i in range(k):
            if b[i] == 1:
                print(b[i], end='')
        print()
    else:
        pass
```



결정이 되었으면 출력



부분집합 원소의 합



```python
def f(n, k, s):
    if n==k:
        print(s)
    else:
        f(n+1, k, s+A[n])
        f(n+1, k, s)
```



문제를 보고 상태 트리를 만들어보는 연습

[#가능한-시험점수]: 