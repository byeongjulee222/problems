[TOC]

# 알고리즘_190729

####  수업 진행 방식

- 1주에 챕터 1장씩 진행

  - 월 : 교재 내용 공부 + 실습 문제 1개
  - 화 : 실습 (실습 문제 4개 + 추가 1개)
  - 문제는 당일에 모두 다 푸는것을 원칙으로 함.

  

  

  

-  추상 자료형 (Abstract Data Type)

  - 문제 풀 때 라이브러리 사용하지 않는다. (직접 구현해보고 이해하는 것이 먼저.)
    - ex) List 사용할 때 max(), min(), index(), sort(), 슬라이싱 사용 X
      - 안에 있는 요소를 수정하는 라이브러리는 사용 X
      - len(), append()와 같이 리스트 전체를 기준으로 하는 것은 사용 O
  - 코딩할 때 쓰는 언어적 표현
    - for, while(반복), if-else(분기) (** 흐름에 대해 이해하는 것이 우선)
    - 수식(연산자)



- 알고리즘 역량 Test 
  - IM (p.16 연습문제 1 수준)
    - 이차원 배열 조작
    - 리스트 인덱스, 반복문 조작
  - AD
    - 완전탐색에 대해 완벽하게 이해하면 된다.





## 알고리즘

### 알고리즘의 성능??

- 실행 시간이 얼마나 짧은가
  - 반복횟수의 다항식에서 가장 높은 차수에 가장 큰 영향을 받음.
    - ex.2n^2 + 7n + 4 에서 n이 커질 때 2n^2 증가량에 비해 7n + 4의 증가량은 미미하다.
- 얼마나 적은 메모리를 사용하는가



- 시간 복잡도가 높다 == 처리량이 늘어남에 따라 처리에 걸리는 시간 증가량이 크다



- ##### 시간 복잡도 표기법 종류

  - 빅-오(O) 표기법(Big O Notation) : 최악의 경우 (주로 사용)
  - 오메가(Omega Notation) : 최선의 경우
  - 씨타(Theta) : 최악 == 최선인 경우 (최고차항이 같은 경우)



- 시간 복잡도 계산 이유?
  - 알고리즘이 실행되는 시간을 예측.



#### 리스트 순차검색

- 최선 : 리스트의 가장 앞에 값이 저장되어 있을 때
- 최악 : 리스트의 가장 뒤에 값이 저장되어 있을 때 or 찾는 값이 리스트에 없을 때
  - 최악의 경우라 가정하고 코드를 작성 (-> 예측이 가능해진다, 빅-오(O))



#### 2진 탐색

- 정렬된 상태이어야 한다.
- 추측을 하면서 찾아갈 수 있다. (가운데 값을 찍어서 큰지 작은지 판단)
- 확인하지 않아도 되는 데이터를 잘라냄

- 전산에서는 log의 밑이 기본적으로 2라 생각하면 됨



####  탐욕 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법

- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

- 선택이 최적이 아니라고 판단하여 고치는 과정 : 백트래킹



#### cf)

- 알고리즘에서 어려운 문제 => 처리시간이 긴 문제
  - P집합(1, logn, n, nlogn, n^2) / NP 집합(2^n, n!)



- 알고리즘에서의 배열(ex.List) : 동일한 자료형의 집합 (자료형이 다른 요소를 넣지 않는다.) C나 Java에서 사용하는 것과 유사하다.
  - ==> 동일한 의미를 갖는 데이터를 넣는다.



###  정렬

####  버블 정렬(Bubble Sort)

- 인접한 두 개의 원소 비교 -> 1, 2 비교 -> 2,3 비교 , ..)

  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

  - 단계가 끝날 때마다 큰 숫자부터 채줘진다.



- 버블 정렬 예)

```python
arr = [55, 7, 78, 12, 42]
n = len(arr)
for i in range(n-1):
    if arr[i] > arr[i+1]:
        arr[i], arr[i+1] = arr[i+1], arr[i]
    
print(arr)
# [7, 55, 12, 42, 78]

for i in range(n-2):
    if arr[i] > arr[i+1]:
        arr[i], arr[i+1] = arr[i+1], arr[i]
    
print(arr)
# [7, 12, 42, 55, 78]

....

*** (n-1)번 반복
```



- 반복되는 것을 이해하고 반복문으로 감싸는 풀이.
  - 순서 : 내부 for문을 이해하고 외부 for문을 작성

```python
arr = [55, 7, 78, 12, 42]
n = len(arr)
for j in range(n-1, 0, -1):
    for i in range(j):
        if arr[i] > arr[i+1]:
            arr[i], arr[i+1] = arr[i+1], arr[i]

print(arr)
```



#### 선택정렬

- 해당 순서에 원소를 넣을 위치가 정해져 있고, 어떤 원소를 넣을지 선택하는 방법



- 선택정렬 예)

```python
arr = [55, 7, 78, 12, 42]

min = arr[0]
for i in range(1, len(arr)):
    if arr[i] < min:
        min = arr[i]
		# 가장 작은 값이 있는 인덱스를 알아야 한다.
        
print(min)
```

```python
arr = [55, 7, 78, 12, 42]

min = 0
for i in range(1, len(arr)):
    if arr[i] < arr[min]:
        min = i

arr[0], arr[min] = arr[min], arr[0]

min = 1
for i in range(min+1, len(arr)):
    if arr[i] < arr[min]:
        min = i

arr[1], arr[min] = arr[min], arr[1]
print(arr)

...
(n-1)번 반복
```



- 반복되는 것을 이해하고 반복문으로 감싸준다.

```python
arr = [55, 7, 78, 12, 42]

for j in range(len(arr) - 1):  # 범위의 시작값이 0부터 n-2까지 반복
    min = j
    for i in range(j + 1, len(arr)):
        if arr[i] < arr[min]:
            min = i

    arr[j], arr[min] = arr[min], arr[j]

print(arr)
```



#### 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 통해 정렬하는 알고리즘.
  - 정렬해야 할 값이 양의 정수일 때 사용 가능.

```python
# 1
data = [0, 3, 1, 3, 1, 2, 4, 1]
counts = [0] * 5    # 최대값 = 4

for val in data:
    counts[val] += 1

# print(counts)  ==> [1, 3, 1, 2, 1]

sorted = []
for i in range(len(counts)):
    for j in range(counts[i]):
        sorted.append(i)

print(sorted)
```



```python
# 2. 누적 빈도수 활용
# 그 숫자가 마지막에 배치되는 위치 = 누적된 counts 값
# ex. 1이 마지막에 배치되는 위치 (4) = 누적된 counts 값 (4)
# 인덱스 값은 위치 값 - 1
# 정렬할 리스트의 가장 마지막 인자부터 결과값에 채워넣는다.

```



```python
# 연습문제 1
data = [7, 4, 2, 0, 0, 6, 0, 7, 0]
# 가장 높은 위치에 있는 상자만 고려하면 됨(그 아래에 상자가 무조건 존재할 것이기 때문)
# 낙폭 = 리스트 길이 - 원소의 인덱스 값

...

```



#### Baby-gin Game (유형 : 결정 문제)

- 완전검색(Exaustive Search)를 통해 모든 경우의 수를 나열해보고 확인해야 한다.

```python
# 6장의 카드를 3장 3장으로 나눈 모든 경우의 수를 따져봐야 한다.
# (6C3 * 3C3) / 2!
```



#### 최적화 문제 (자주 출제)

- 기본 접근 방법 -> 완전 검색 방법
  - 최대 혹은 최소가 되는 경우를 찾는 문제
  - 모든 가능한 경우를 조사한다.
  - 모든 후보해를 조사한다
  - 모든 가능한 경우들이 조합과 관련이 깊다.
    - 순열, 부분집합, 조합
    - n!, 2^n

- 조건을 만족하는 값이 최대 혹은 최소가 되는 경우를 찾는 문제
  - ex. 최소 경로 or 최소 금액으로 도착하는 경로



---> 좀 더 빠른 방법이 없을까?

- 완전 검색을 좀더 효율적으로 하는 방법

1. 백트래킹(가지치기)
2. 동적 계획법(메모이제이션)











practice_번호.py로 저장

input.txt 도 저장